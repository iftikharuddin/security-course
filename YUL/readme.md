# YUL

- assembly block
    - assembly { }
- slots, starts from 0 and goes on
    - one slot can store many variables if datatype is small
    - e.g uint128, uint128 can be in one slot
    - when you define a variable public, the getter is generated by default
- sload(var.slot) => will get the slot value, it will be the 32 bytes word
- bitwise masking?
    - value and 0 = 0
    - value and 1 = value
    - value or 0 = value   
- e.g add(oldValue, 0xffff0000......goes to 32nd) 
    - ... this will set the old slot value to 0000 (clear it)
    - also the ffff means that corresponding value will be preserved
    
    - e.g we have oldValue          0x02034560203304040400000000004
    - then mask will be             0xffff0000fffffffffffffffffffff
    - in this clear value will be   0x02030000203304040400000000004
- shl, shr => shift left, shift right
- Working with memory in Yul (mstore & mstore8)
- Solidity, no garbage collection
    - Memory is arranged in 32 bytes sequences
    - Only 4 instructions: mload, mstore, mstore8, and msize
- Basics of working with the free memory pointer via Yul
    - Lack of free memory pointer management
    - In solidity, the 0x40 slot in memory is special: it contains the "free memory pointer" which points to the end of the currently allocated memory.
    - When you use inline assembly, you should load the data stored at 0x40 and then only write to addresses after the result. When you're done, if you want to keep that memory allocated, you should overwrite 0x40 with the new value of the free memory pointer.
    - ref ( https://ether``eum.stackexchange.com/questions/9603/understanding-mload-assembly-function )